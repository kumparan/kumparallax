'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = onDropFile;

var _addBlock = require('./addBlock');

var _addBlock2 = _interopRequireDefault(_addBlock);

var _replaceBlock = require('./replaceBlock');

var _replaceBlock2 = _interopRequireDefault(_replaceBlock);

var _modifyBlockData = require('./modifyBlockData');

var _modifyBlockData2 = _interopRequireDefault(_modifyBlockData);

var _file = require('../utils/file');

var _block = require('../utils/block');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function defaultHandlePlaceholder(state, selection, data, defaultBlockType) {
  return (0, _addBlock2.default)(state, selection, defaultBlockType, data);
}

/* function defaultHandleBlock(state, selection, data, defaultBlockType) {
  return addBlock(state, selection, defaultBlockType, data);
} */

function onDropFile(config) {
  return function onDropFileInner(selection, files, _ref) {
    var getEditorState = _ref.getEditorState;
    var setEditorState = _ref.setEditorState;

    // Get upload function from config or editor props
    var handleUpload = config.handleUpload;
    var handlePlaceholder = config.handlePlaceholder;
    var handleBlock = config.handleBlock;
    var defaultBlockType = config.defaultBlockType;
    var handleProgress = config.handleProgress;

    if (handleUpload) {
      var _ret = function () {
        var formData = new FormData();

        // Set data {files: [Array of files], formData: FormData}
        var data = { files: [], formData: formData };
        for (var key in files) {
          if (files[key] && files[key] instanceof File) {
            data.formData.append('files', files[key]);
            data.files.push(files[key]);
          }
        }

        // Read files on client side
        (0, _file.readFiles)(data.files).then(function (placeholders) {
          // Add blocks for each image before uploading
          var state = getEditorState();
          placeholders.forEach(function (placeholder) {
            var newEditorStateOrBlockType = handleBlock ? handlePlaceholder(state, selection, _extends({}, placeholder, { progress: 1 })) : defaultHandlePlaceholder(state, selection, _extends({}, placeholder, { progress: 1 }), defaultBlockType);

            if (!newEditorStateOrBlockType) {
              state = defaultHandlePlaceholder(state, selection, _extends({}, placeholder, { progress: 1 }), defaultBlockType);
            } else if (typeof newEditorStateOrBlockType === 'string') {
              state = defaultHandlePlaceholder(state, selection, _extends({}, placeholder, { progress: 1 }), newEditorStateOrBlockType);
            } else {
              state = newEditorStateOrBlockType;
            }
          });
          setEditorState(state);

          // Perform upload
          handleUpload(data, function (uploadedFiles) {
            // Success, remove 'progress' and 'src'
            var newEditorState = getEditorState();
            uploadedFiles.forEach(function (file) {
              var blocks = (0, _block.getBlocksWhereEntityData)(state, function (block) {
                return block.src === file.src && block.progress !== undefined;
              });
              if (blocks.size) {
                var newEditorStateOrBlockType = handleBlock ? handleBlock(newEditorState, newEditorState.getSelection(), file) : defaultBlockType;
                newEditorState = (0, _replaceBlock2.default)(newEditorState, blocks.first().get('key'), newEditorStateOrBlockType);
              } /* else {
                const newEditorStateOrBlockType = handleBlock
                  ? handleBlock(newEditorState, newEditorState.getSelection(), file)
                  : defaultHandleBlock(newEditorState, newEditorState.getSelection(), file, defaultBlockType);
                 if (!newEditorStateOrBlockType) {
                  newEditorState = defaultHandleBlock(newEditorState, selection, file, defaultBlockType);
                } else if (typeof newEditorStateOrBlockType === 'string') {
                  newEditorState = defaultHandleBlock(newEditorState, selection, file, newEditorStateOrBlockType);
                } else {
                  newEditorState = newEditorStateOrBlockType;
                }
                } */
            });

            // Propagate progress
            if (handleProgress) handleProgress(null);
            setEditorState(newEditorState);
          }, function () {
            // console.error(err);
          }, function (percent) {
            // On progress, set entity data's progress field
            var newEditorState = getEditorState();
            placeholders.forEach(function (placeholder) {
              var blocks = (0, _block.getBlocksWhereEntityData)(newEditorState, function (p) {
                return p.src === placeholder.src && p.progress !== undefined;
              });
              if (blocks.size) {
                newEditorState = (0, _modifyBlockData2.default)(newEditorState, blocks.first().get('key'), { progress: percent });
              }
            });
            setEditorState(newEditorState);

            // Propagate progress
            if (handleProgress) {
              handleProgress(percent);
            }
          });
        });

        return {
          v: true
        };
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }

    return undefined;
  };
}